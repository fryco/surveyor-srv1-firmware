<html><head>

<link rel="stylesheet" href="style_product.css" type="text/css"><title>SRV-1 C Interpreter</title></head><body>
<a href="http://www.surveyor.com/"><img src="http://www.surveyor.com/images/surveyor.gif" border="0"></a><br>
<h3>SRV-1 C Interpreter - as of 
15 March 2009</h3>

<table width="640">
<tbody>
If you are looking for documentation on the "Small C interpreter" built into SRV-1 firmware prior to 15 March 2009, see <a href="http://www.surveyor.com/SRV_protocol_020609.html">SRV_protocol_020609.html</a><br>
<br>
The new SRV-1 C interpreter is based on the <a href="http://code.google.com/p/picoc/">picoC open source C interpreter</a>.  Full documentation for picoC is in the works, but for now, we are providing some code samples that highlight capabilities.<br>
<br>
<blockquote>
<b>/*     comments    */</b><br>
printf("Hello\n"); /* this is a comment */</b><br>printf("Hello\n");  // this is also a comment<br>
<br>
<b>/*     printf     */</b><br>
int Count;<br>for (Count = -5; Count <= 5; Count++)<br>    &nbsp;&nbsp;printf("Count = %d\n", Count);<br><br>printf("String 'hello', 'there' is '%s', '%s'\n", "hello", "there");<br>printf("Character 'A' is '%c'\n", 65);<br>printf("Character 'a' is '%c'\n", 'a');<br><br>
<b>/*     structs   */</b><br>
struct fred<br>{<br>    &nbsp;&nbsp;int boris;<br>    &nbsp;&nbsp;int natasha;<br>};<br>struct fred bloggs;<br><br>bloggs.boris = 12;<br>bloggs.natasha = 34;<br>printf("%d\n", bloggs.boris);<br>printf("%d\n", bloggs.natasha);<br><br>
<b>/*    array    */</b><br>
int Count;<br>int Array[10];<br>for (Count = 1; Count <= 10; Count++)<br>    &nbsp;&nbsp;Array[Count-1] = Count * Count;<br>for (Count = 0; Count < 10; Count++)<br>    &nbsp;&nbsp;printf("%d\n", Array[Count]);<br><br>
<b>/*    switch   */</b><br>
int Count;<br>for (Count = 0; Count < 4; Count++)<br>{<br>    &nbsp;&nbsp;printf("%d\n", Count);<br>    &nbsp;&nbsp;switch (Count)<br>    &nbsp;&nbsp;{<br>        &nbsp;&nbsp;&nbsp;&nbsp;case 1:<br>            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%d\n", 1);<br>	    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>       &nbsp;&nbsp;&nbsp;&nbsp; case 2:<br>            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%d\n", 2);<br>	    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>        &nbsp;&nbsp;&nbsp;&nbsp;default:<br>            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%d\n", 0);<br>            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>    &nbsp;&nbsp;}<br>}<br><br>
<b>/*    while + do while  */</b><br>
int a;<br>int p;<br>int t;<br>a = 1;<br>p = 0;<br>t = 0;<br>while (a < 100)<br>{<br>    &nbsp;&nbsp;printf("%d\n", a);<br>    &nbsp;&nbsp;t = a;<br>    &nbsp;&nbsp;a = t + p;<br>    &nbsp;&nbsp;p = t;<br>}<br>
<br>do<br>{<br>    &nbsp;&nbsp;printf("%d\n", a);<br>    &nbsp;&nbsp;t = a;<br>    &nbsp;&nbsp;a = t + p;<br>    &nbsp;&nbsp;p = t;<br>} while (a < 100);<br><br>
<b>/*  pointer */</b><br>
int a;<br>int *b;<br>int c;<br><br>a = 42;<br>b = &a;<br>printf("a = %d\n", *b);<br><br>struct ziggy<br>{<br>    &nbsp;&nbsp;int a;<br>    &nbsp;&nbsp;int b;<br>    &nbsp;&nbsp;int c;<br>} bolshevic;<br><br>bolshevic.a = 12;<br>bolshevic.b = 34;<br>bolshevic.c = 56;<br><br>printf("bolshevic.a = %d\n", bolshevic.a);<br>printf("bolshevic.b = %d\n", bolshevic.b);<br>printf("bolshevic.c = %d\n", bolshevic.c);<br><br>struct ziggy *tsar = &bolshevic;<br><br>printf("tsar->a = %d\n", tsar->a);<br>printf("tsar->b = %d\n", tsar->b);<br>printf("tsar->c = %d\n", tsar->c);<br><br>
<b>/*  #define  */</b><br>
#define FRED 12<br>#define BLOGGS(x) (12*(x))<br><br>printf("%d\n", FRED);<br><br>
<b>/*  integers  */</b><br>
int a = 24680;<br>int b = 01234567;<br>int c = 0x2468ac;<br>int d = 0x2468AC;<br>int e = 0b010101010101;<br><br>printf("%d\n", a);<br>printf("%d\n", b);<br>printf("%d\n", c);<br>printf("%d\n", d);<br><br>
<b>/*   if   */</b><br>
int a = 1;<br>if (a)<br>    &nbsp;&nbsp;printf("a is true\n");<br>else<br>    &nbsp;&nbsp;printf("a is false\n");<br><br>int b = 0;<br>if (b)<br>    &nbsp;&nbsp;printf("b is true\n");<br>else<br>    &nbsp;&nbsp;printf("b is false\n");<br><br>
<b>/*   recursion  */</b><br>
int factorial(int i) <br>{<br>    &nbsp;&nbsp;if (i < 2)<br>        &nbsp;&nbsp;&nbsp;&nbsp;return i;<br>    &nbsp;&nbsp;else<br>        &nbsp;&nbsp;&nbsp;&nbsp;return (i * factorial(i - 1));<br>}<br><br>
int Count;<br>for (Count = 1; Count <= 10; Count++)<br>    &nbsp;&nbsp;printf("%d\n", factorial(Count));<br><br>
<b>/*  nesting  */</b><br>int x, y, z;<br>for (x = 0; x < 2; x++)<br>{<br>    &nbsp;&nbsp;for (y = 0; y < 3; y++)<br>    &nbsp;&nbsp;{<br>        &nbsp;&nbsp;&nbsp;&nbsp;for (z = 0; z < 3; z++)<br>        &nbsp;&nbsp;&nbsp;&nbsp;{<br>            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%d %d %d\n", x, y, z);<br>        &nbsp;&nbsp;&nbsp;&nbsp;}<br>    &nbsp;&nbsp;}<br>}<br><br><br>
<b>/* Robot Functions  */</b><br>
<br>
int signal()  -  non-blocking check for input on serial channel<br>
int input()  -  blocking read of serial channel<br>
void delay(int)  -  delay xxx milliseconds<br>
int rand(int) - return random number ranging from 0 to xxx<br>
int time()  -  return time in milliseconds since startup<br>
void motors(int, int) - set left and right PWM motor power -100 - 100<br>
void servos(int, int) - set pin 7/8 (tmr 2/3) PPM levels 0 - 100<br>
void servos2(int, int) - set pin 5/6 (tmr 6/7) PPM levels 0 - 100<br>
void laser(int) - 0=off, 1=left, 2=right, 3=both<br>
void sonar(int) - ping modules 1, 2, 3 or 4<br>
int range() - use laser pointer to estimate range<br>
void vcolor(int, int, int, int, int, int, int) - set color bin with ymin, ymax, umin, umax,  
     vmin, vmax<br>
void vcap() - capture video frame<br>
void vrcap() - capture reference frame for differencing<br>
void vdiff(int) - enable/disable differencing with vcap()<br>
void vpix(int, int) - get YUV values of vpix(x, y)<br>
void vmean() - get YUV means over full frame<br>
int vblob(int, int) - blob search on color xxx - returns number of blobs found -  
     2nd value determines which blob (largest to smallest)<br>
int compass() - read HMC6352 compass<br>
void gps() - parse $GPGGA string from gps<br>
int readi2c(int, int) - read byte from I2C port<br>
int readi2c2(int, int) - read short from I2C port<br>
void writei2c(int, int, int) - write byte to I2C port<br>
int sin(int) - sin(angle) * 100<br>
int cos(int) - cos(angle) * 100<br>
int tan(int) - tan(angle) * 100<br>
int asin(int, int) - arcsin(opposite, hypotenuse)<br>
int acos(int, int) - arccos(adjacent, hypotenuse)<br>
int atan(int, int) - arctan(opposite, adjacent)<br>
int nninit() - initialize neural net<br>
int nntrain() - train neural net<br>
int nnset(int, int, int, int, int, int, int, int, int) - set nn pattern<br>
int nnshow(int) - display nn pattern<br>
int nntest(int, int, int, int, int, int, int, int) - test nn pattern<br>
int nnlearnblob(int) - scale and save blob to 8x8 pattern<br>
int nnmatchblob(int) - see which pattern is best match to selected blob<br>
<br>
</blockquote>
</tbody></table>
<br><br>
last updated 15 March 2009 - 23:50 GMT
<br>
<script src="urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-226226-1";
urchinTracker();
</script>

</body></html>
