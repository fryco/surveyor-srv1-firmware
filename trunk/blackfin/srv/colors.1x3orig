#include "colors.h"

extern imgWidth, imgHeight;

unsigned int ymax[MAX_COLORS], ymin[MAX_COLORS], umax[MAX_COLORS], umin[MAX_COLORS], vmax[MAX_COLORS], vmin[MAX_COLORS];
unsigned int blobx1[MAX_BLOBS], blobx2[MAX_BLOBS], bloby1[MAX_BLOBS], bloby2[MAX_BLOBS], blobcnt[MAX_BLOBS];
unsigned int hist0[256], hist1[256], mean[3];

void init_colors() {
    unsigned int ii;
    
    for(ii = 0; ii<MAX_COLORS; ii++) {
        ymax[ii] = 0;
        ymin[ii] = 0;
        umax[ii] = 0;
        umin[ii] = 0;
        vmax[ii] = 0;
        vmin[ii] = 0;
    }
}

unsigned int vpix(unsigned char *frame_buf, unsigned int xx, unsigned int yy) {
        unsigned int ix;
        ix = index(xx,yy);  // use scaled coordinates
        return    ((unsigned int)frame_buf[ix] << 24) +    // returns UYVY packed into 32-bit word
                        ((unsigned int)frame_buf[ix+1] << 16) +
                        ((unsigned int)frame_buf[ix+2] << 8) +
                        (unsigned int)frame_buf[ix+3];
}

void vblob(unsigned char *frame_buf, unsigned int ii) {
    unsigned int jj, ix, xx, yy, y, u, v, count, bottom, top, tmp;
    unsigned int maxx, maxy;

    maxx = imgWidth;
    maxy = imgHeight;

    for (jj=0; jj<MAX_BLOBS; jj++) {
        blobcnt[jj] = 0;
        blobx1[jj] = maxx;
        blobx2[jj] = 0;
        bloby1[jj] = maxy;
        bloby2[jj] = 0;
    }
        
    jj = 0;    // jj indicates the current blob being processed
    for (xx=0; xx<maxx; xx++) {
        count = 0;
        bottom = maxy;
        top = 0;
        for (yy=0; yy<maxy; yy++) {
            ix = index(xx,yy);
            y = (((unsigned int)frame_buf[ix+1] + (unsigned int)frame_buf[ix+3])) >> 1;
            u = (unsigned int)frame_buf[ix];
            v = (unsigned int)frame_buf[ix+2];
            if ((y >= ymin[ii])
             && (y <= ymax[ii]) 
             && (u >= umin[ii]) 
             && (u <= umax[ii]) 
             && (v >= vmin[ii]) 
             && (v <= vmax[ii])) {
                count++;
                if (bottom > yy)
                    bottom = yy;
                if (top < yy)
                    top = yy;
            }
        }
        if (count) {
            if (bloby1[jj] > bottom)
                bloby1[jj] = bottom;
            if (bloby2[jj] < top)
                bloby2[jj] = top;
            if (blobx1[jj] > xx)
                blobx1[jj] = xx;
            if (blobx2[jj] < xx)
                blobx2[jj] = xx;
            blobcnt[jj] += count;
        } else {
            if (blobcnt[jj])    // move to next blob if a gap is found
                jj++;
            if (jj > (MAX_BLOBS-2))
                goto blobbreak;
        }
    }
blobbreak:     // now sort blobs by size, largest to smallest pixel count
    for (xx=0; xx<=jj; xx++) {
        if (blobcnt[xx] == 0)    // no more blobs, so exit
            return;
        for (yy=xx; yy<=jj; yy++) {
            if (blobcnt[yy] == 0)
                break;
            if (blobcnt[xx] < blobcnt[yy]) {
                tmp = blobcnt[xx];
                blobcnt[xx] = blobcnt[yy];
                blobcnt[yy] = tmp;
                tmp = blobx1[xx];
                blobx1[xx] = blobx1[yy];
                blobx1[yy] = tmp;
                tmp = blobx2[xx];
                blobx2[xx] = blobx2[yy];
                blobx2[yy] = tmp;
                tmp = bloby1[xx];
                bloby1[xx] = bloby1[yy];
                bloby1[yy] = tmp;
                tmp = bloby2[xx];
                bloby2[xx] = bloby2[yy];
                bloby2[yy] = tmp;
            }
        }
    }
}

// histogram function - 
//  hist0[] holds frequency of u|v combination  
//  hist1[] holds average luminance corresponding each u|v combination

void vhist(unsigned char *frame_buf) {
    unsigned int ix, iy, xx, yy, y1, u1, v1;
    unsigned int maxx, maxy;

    maxx = imgWidth;
    maxy = imgHeight;

    for (ix=0; ix<256; ix++) {          hist0[ix] = 0;  // accumulator 
        hist1[ix] = 0;  
    }
    for (xx=0; xx<maxx; xx++) {   
        for (yy=0; yy<maxy; yy++) {
            ix = index(xx,yy);  
            y1 = (((unsigned int)frame_buf[ix+1] + (unsigned int)frame_buf[ix+3])) >> 1;
            u1 = ((unsigned int)frame_buf[ix]);
            v1 = ((unsigned int)frame_buf[ix+2]);
            iy = (u1 & 0xF0) + (v1 >> 4);
            hist0[iy]++;
            hist1[iy] += y1;
        }
    }
    for (ix=0; ix<256; ix++)
        hist1[ix] /= hist0[ix];  // normalize by number of hits
}

// mean color function - computes mean value for Y, U and V
//   mean[0] = Y mean, mean[1] = U mean, mean[2] = V mean
void vmean(unsigned char *frame_buf) {
    unsigned int ix, xx, yy, y1, u1, v1;
    unsigned int my, mu, mv;
    unsigned int maxx, maxy;

    maxx = imgWidth;
    maxy = imgHeight;
    my = mu = mv = 0;

    for (xx=0; xx<maxx; xx++) {   
        for (yy=0; yy<maxy; yy++) {
            ix = index(xx,yy);  // yx, uv, vx range from 0-63 (yuv value divided by 4)
            y1 = (((unsigned int)frame_buf[ix+1] + (unsigned int)frame_buf[ix+3])) >> 1;
            u1 = ((unsigned int)frame_buf[ix]);
            v1 = ((unsigned int)frame_buf[ix+2]);
            my += y1;
            mu += u1;
            mv += v1;
        }
    }
    mean[0] = (my / maxx) / maxy;
    mean[1] = (mu / maxx) / maxy;
    mean[2] = (mv / maxx) / maxy;
}

void color_segment(unsigned char *frame_buf) {
    unsigned int ix, xx, yy, y, u, v, clr;
    unsigned int ymid[MAX_COLORS], umid[MAX_COLORS], vmid[MAX_COLORS];
    
    for (ix=0; ix<MAX_COLORS; ix++) {
        ymid[ix] = (ymax[ix] + ymin[ix]) >> 1;
        umid[ix] = (umax[ix] + umin[ix]) >> 1;
        vmid[ix] = (vmax[ix] + vmin[ix]) >> 1;
    }
    for (xx=0; xx<imgWidth; xx+=2) {   
        for (yy=0; yy<imgHeight; yy++) {
            ix = index(xx,yy);
            y = (((unsigned int)frame_buf[ix+1] + (unsigned int)frame_buf[ix+3])) >> 1;
            //y = (unsigned int)frame_buf[ix+1];
            u = (unsigned int)frame_buf[ix];
            v = (unsigned int)frame_buf[ix+2];
            for (clr=0; clr<MAX_COLORS; clr++) {
                if (ymax[clr] == 0)    // skip this color if not defined
                    continue;
                if ((y >= ymin[clr])
                  && (y <= ymax[clr]) 
                  && (u >= umin[clr]) 
                  && (u <= umax[clr]) 
                  && (v >= vmin[clr]) 
                  && (v <= vmax[clr])) {
                    frame_buf[ix+1] = frame_buf[ix+3] = ymid[clr];
                    frame_buf[ix] = umid[clr];
                    frame_buf[ix+2] = vmid[clr];
                    break;
                }
            }
            if (clr == MAX_COLORS) {  // if no match, black out the pixel
                frame_buf[ix+1] = frame_buf[ix+3] = 0;
                frame_buf[ix] = frame_buf[ix+2] = 128;
            }
        }
    }
}

void edge_detect(unsigned char *inbuf, unsigned char *outbuf, int thresh) {
    unsigned int ix, xx, yy, zz, y1, y2, u1, u2, v1, v2, skip;
    unsigned int *ip, *op;
    unsigned int gx, gy, tmp;
    
    op = (unsigned int *)outbuf;
    for (ix=0; ix<(imgWidth*imgHeight>>1); ix++)
        op[ix] = 0x00800080;  // preset Y=0, U/V = 128
    
    skip = imgWidth*2;
    for (xx=2; xx<imgWidth-2; xx+=2) {   
        for (yy=1; yy<imgHeight-1; yy++) {
            gx = gy = 0;
            ix = index(xx, yy);
            y1 = (((unsigned int)inbuf[ix-3] + (unsigned int)inbuf[ix-1])) >> 1;
            u1 = (unsigned int)inbuf[ix-4];
            v1 = (unsigned int)inbuf[ix-2];
            y2 = (((unsigned int)inbuf[ix+5] + (unsigned int)inbuf[ix+7])) >> 1;
            u2 = (unsigned int)inbuf[ix+4];
            v2 = (unsigned int)inbuf[ix+6];
            tmp = (y2-y1)*(y2-y1) + (u2-u1)*(u2-u1) + (v2-v1)*(v2-v1);
            gy += tmp;

            y1 = (((unsigned int)inbuf[ix+1-skip] + (unsigned int)inbuf[ix+3-skip])) >> 1;
            u1 = (unsigned int)inbuf[ix-skip];
            v1 = (unsigned int)inbuf[ix+2-skip];
            y2 = (((unsigned int)inbuf[ix+1+skip] + (unsigned int)inbuf[ix+3+skip])) >> 1;
            u2 = (unsigned int)inbuf[ix+skip];
            v2 = (unsigned int)inbuf[ix+2+skip];
            tmp = (y2-y1)*(y2-y1) + (u2-u1)*(u2-u1) + (v2-v1)*(v2-v1);
            gx += tmp;

            if ((gx > thresh) || (gy > thresh)) {
                outbuf[ix+1] = outbuf[ix+3] = 192;
                if (gx > gy) {
                    outbuf[ix] = 0;
                    outbuf[ix+2] = 0;
                } else {
                    outbuf[ix+2] = 255;
                    outbuf[ix] = 255;
                }
            }
        }
    }


    op = (unsigned int *)outbuf;
    ip = (unsigned int *)inbuf;
    for (ix=0; ix<(imgWidth*imgHeight>>1); ix++)
        ip[ix] = op[ix];
}

